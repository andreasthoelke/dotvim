

func! Scala_SetServerApp_ScalaCLI()
  let printerFilePath = getcwd() . '/PreviewServer_Ember.scala'

  let hostLn = searchpos( '\v^(lazy\s)?val\s', 'cnbW' )[0]
  let identif = matchstr( getline(hostLn ), '\v(val|def)\s\zs\i*\ze\W' )
  let identif = Sc_PackagePrefix() . Sc_ObjectPrefix(hostLn) . identif

  call VirtualRadioLabel_lineNum( "« httpApp" , hostLn )

  let bindingLine = "val httpApp = " . identif

  let printerLines = readfile( printerFilePath, '\n' )
  let printerLines[1] = bindingLine

  call writefile( printerLines, printerFilePath )
endfunc


let g:Scala_ServerCmd_Zio   = "scala-cli . --main-class PreviewServer --class-path resources -nowarn -Ymacro-annotations"
let g:Scala_ServerCmd_Ember = "scala-cli . --main-class server_ember.PreviewServer_Ember --class-path resources -nowarn -Ymacro-annotations"



" ─   PreviewServer                                     ──
" async running process scala-cli . --main-class PreviewServer
" can be started in term (to debug) or as job (invisible)
" no need for callback handlers
" can be jobstop'ed and restarted with new compiled scala-cli . --main-class PreviewServer

func! Scala_ServerRestart ()
  if !exists('g:Scala_ServerID')
    call Scala_ServerStart()
  else
    call Scala_ServerStop()
    call Scala_ServerStart()
  endif
endfunc

func! Scala_ServerRestartTerm ()
  if !exists('g:Scala_ServerID')
    call Scala_ServerStartT()
  else
    call Scala_ServerStop()
    call Scala_ServerStartT()
  endif
endfunc


func! ScalaServerMainCallback(job_id, data, event)
  " call Scala_ServerClientRequest_rerun()
  " call T_DelayedCmd( "call Scala_ServerClientRequest_rerun()", 1000 )
  return
  let lines = RemoveTermCodes( a:data )
  if !len( lines )
    return
  endif
  silent let g:floatWin_win = FloatingSmallNew ( lines )
  silent call FloatWin_FitWidthHeight()
  silent wincmd p
endfunc


let g:ScalaServerCallbacks = {
      \ 'on_stdout': function('ScalaServerMainCallback'),
      \ 'on_stderr': function('ScalaReplErrorCallback'),
      \ 'on_exit': function('ScalaReplExitCallback')
      \ }


func! Scala_ServerStart ()
  if exists('g:Scala_ServerID') | call T_echo( 'Scala_Server is already running' ) | return | endif
  silent let g:Scala_ServerID = jobstart( g:Scala_ServerCmd_Ember, g:ScalaServerCallbacks )
endfunc

func! Scala_ServerStartT ()
  if exists('g:Scala_ServerID') | call T_echo( 'Scala_Server is already running' ) | return | endif
  exec "8new"
  let g:Scala_ServerID = termopen( g:Scala_ServerCmd_Ember )
  silent wincmd p
endfunc


func! Scala_ServerStop ()
  if !exists('g:Scala_ServerID') | call T_echo( 'Scala_Server is not running' ) | return | endif
  silent call jobstop( g:Scala_ServerID )
  unlet g:Scala_ServerID
endfunc


" func! Scala_ServerClientRequest( args )
"   let urlExtension = GetLineFromCursor()
"   let g:scala_serverRequestCmd = "curl " . a:args . "http://localhost:8003/" . urlExtension
"   let resultLines = split( system( g:scala_serverRequestCmd ), '\n' )
"   silent let g:floatWin_win = FloatingSmallNew ( resultLines[3:] )
"   silent call FloatWin_FitWidthHeight()
"   silent wincmd p
" endfunc

" httpx -m PUT http://127.0.0.1:5000/actors -p filter_name "Robert Downey Jr." -j '{"age": 57, "height": 173}'
" httpx --help

" actors PUT -p filter_name "Robert Downey Jr." -j '{"age": 57, "height": 173}'
" conversion for my short version: don't use the -m key. all options after URL are optional. but the sequnce is fixed to how they appear in the --help


let g:httpport = 8080
" let g:httpport = 5000
" let g:httpdomain = '127.0.0.1'
let g:httpdomain = 'localhost'

func! Httpx_parse( source, result )
  if     a:source[0][0] == "-"
    let val = join( a:source, " " )
    let rest = []

  " elseif a:source[0] == "-j"
  elseif a:source[0] =~ '\v(POST|PUT|DELETE|UPDATE)'
    let val = "-m " . a:source[0]
    let rest = a:source[1:]
  else
    let val = "-m GET"
    let rest = a:source
  endif

  return [rest, a:result . " " . val]
endfunc

func! Scala_ServerClientRequest_x()
  let sourceLineItems = split( matchstr( getline("."), '\v(//\s)?\zs.*' ), " " )

  let url = sourceLineItems[0]
  let sourceLineItems = sourceLineItems[1:]

  " call append(line('.'), sourceLineItems)
  
  let extension = ""

  while len( sourceLineItems )
    let [sourceLineItems, extension] = Httpx_parse( sourceLineItems, extension )
  endwhile

  " echo extension
  " return

  let url = "http://" . g:httpdomain . ":" . g:httpport . "/" . url

  let g:scala_serverRequestCmd = "httpx " . url . extension
  " call append(line('.'), g:scala_serverRequestCmd)
  " return

  let resultLines = split( system( g:scala_serverRequestCmd ), '\n' )

  let jsonStartLine = functional#find( resultLines, '\v^(\{|\[)' )
  if jsonStartLine != -1
    let resultLines = resultLines[jsonStartLine:]
  endif
  " call Scala_showInFloat( resultLines )
  silent let g:floatWin_win = FloatingSmallNew ( resultLines )
  if len( resultLines ) && !(resultLines[0] =~ 'error') && !(resultLines[0] =~ 'html')
    if jsonStartLine != -1
      silent exec "%!jq"
      call tools_edgedb#addObjCountToBuffer()
    endif
  endif

  set ft=json
  call TsSyntaxAdditions()
  silent call FloatWin_FitWidthHeight()
  silent wincmd p

endfunc


func! Scala_ServerClientRequest( args, mode )
  let urlEx = matchstr( getline("."), '\v(//\s)?\zs.*' )

  " let g:scala_serverRequestCmd = "http " . a:args . " :" . g:httpport . "/" . urlEx . " --ignore-stdin --stream"
  let g:scala_serverRequestCmd = "http " . a:args . " " . g:httpdomain . ":" . g:httpport . "/" . urlEx . " --ignore-stdin --stream"
  " call append(line('.'), g:scala_serverRequestCmd)
  " return
  if a:mode == 'term'
    call TermOneShot( g:scala_serverRequestCmd )
  else
    let resultLines = split( system( g:scala_serverRequestCmd ), '\n' )
    " call Scala_showInFloat( resultLines )
    silent let g:floatWin_win = FloatingSmallNew ( resultLines )
    if len( resultLines ) && !(resultLines[0] =~ 'error') && !(resultLines[0] =~ 'html')
      silent exec "%!jq"
    endif

    set ft=json
    call TsSyntaxAdditions()
    silent call FloatWin_FitWidthHeight()
    silent wincmd p
    " silent let g:floatWin_win = FloatingSmallNew ( resultLines )
    " silent call FloatWin_FitWidthHeight()
  endif
  " silent wincmd p
endfunc
" http --help
" echo system( "http localhost:8002/fruits/a eins=zwei --ignore-stdin" )
" echo system( "http localhost:8002/users name=zwei age=44 --ignore-stdin" )
" echo system( "curl -X POST localhost:8002/fruits/a --raw eins=zwei" )


func! Scala_ServerClientRequest_rerun()
  let resultLines = split( system( g:scala_serverRequestCmd ), '\n' )
  silent let g:floatWin_win = FloatingSmallNew ( resultLines )
  silent call FloatWin_FitWidthHeight()
  silent wincmd p
endfunc



